package com.intuit.innersource.reposcanner.commands.report;

import com.google.common.collect.Iterables;
import com.intuit.innersource.reposcanner.jsonservice.JsonService;
import com.intuit.innersource.reposcanner.repofilepath.RepositoryFilePath;
import com.intuit.innersource.reposcanner.specification.InnerSourceReadinessSpecification;
import com.intuit.innersource.reposcanner.specification.InnerSourceReadinessSpecification.DirectoriesToSearch;
import com.intuit.innersource.reposcanner.specification.InnerSourceReadinessSpecification.FileCheck;
import com.intuit.innersource.reposcanner.specification.InnerSourceReadinessSpecification.FileChecks;
import com.intuit.innersource.reposcanner.specification.InnerSourceReadinessSpecification.FileRequirement;
import com.intuit.innersource.reposcanner.specification.InnerSourceReadinessSpecification.FileRequirementOption;
import com.intuit.innersource.reposcanner.specification.InnerSourceReadinessSpecification.FileToFind;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import org.immutables.gson.Gson;
import org.immutables.value.Value.Derived;
import org.immutables.value.Value.Immutable;
import org.immutables.value.Value.Style;
import org.immutables.value.Value.Style.BuilderVisibility;
import org.immutables.value.Value.Style.ImplementationVisibility;

/**
 * A report on the InnerSource readiness of a git repository according to some {@link InnerSourceReadinessSpecification}
 * and generated by executing a {@link InnerSourceReadinessReportCommand}.
 *
 * @author Matt Madson
 * @see InnerSourceReadinessReportCommand
 * @see InnerSourceReadinessSpecification
 * @since 1.0.0
 */
@Gson.TypeAdapters
@Immutable
@Style(
    visibility = ImplementationVisibility.PACKAGE,
    builderVisibility = BuilderVisibility.PACKAGE
)
public abstract class InnerSourceReadinessReport {

    /**
     * An immutable report for an individual {@link FileCheck} which indicates if the FileCheck was satisfied or not at
     * the time the repository was scanned.
     *
     * @author Matt Madson
     * @since 1.0.0
     */
    @Immutable
    @Style(
        visibility = ImplementationVisibility.PACKAGE,
        builderVisibility = BuilderVisibility.PACKAGE
    )
    public abstract static class FileCheckReport {

        FileCheckReport() {}

        /**
         * Returns the {@link FileCheck} that was evaluated as part of the {@link InnerSourceReadinessReportCommand} and
         * for which {@code this} report pertains to.
         *
         * @return the file check defined in the {@link InnerSourceReadinessSpecification} that was evaluated
         */
        public abstract FileCheck getFileCheckEvaluated();

        /**
         * Returns true if the {@link #getFileCheckEvaluated()} was satisfied during the report command, false
         * otherwise.
         *
         * @return true if evaluated file check was satisfied, false otherwise.
         */
        public abstract boolean isFileCheckSatisfied();
    }

    /**
     * An immutable report on a collection of {@link FileChecks} which indicates in the FileChecks were satisfied or not
     * at the time the repository was scanned.
     *
     * @author Matt Madson
     * @since 1.0.0
     */
    @Immutable
    @Style(
        visibility = ImplementationVisibility.PACKAGE,
        builderVisibility = BuilderVisibility.PACKAGE
    )
    public abstract static class FileChecksReport {

        FileChecksReport() {}

        /**
         * Returns the file or directory that was evaluated for the set of {@link FileChecks} that {@code this} report
         * pertains to.
         *
         * @return the file or directory that was evaluated against {@code FileChecks}.
         */
        public abstract RepositoryFilePath getFileEvaluated();

        /**
         * Returns the {@link FileChecks} specified in the {@link InnerSourceReadinessSpecification} that were evaluated
         * on the {@link #getFileEvaluated()}.
         *
         * @return the file checks in the readiness specification that were evaluated as part of scanning a git repo and
         * generating this report.
         */
        public abstract FileChecks getFileChecksEvaluated();

        /**
         * Returns the list of {@link FileCheckReport}, one for each {@link FileCheck} in the set of evaluated {@link
         * FileChecks} indicating which FileCheck was or was not satisfied for the scanned {@link RepositoryFilePath}.
         *
         * @return the list of {@code FileCheckReport} indicating if each check was or was not satisfied.
         */
        public abstract List<FileCheckReport> getFileCheckReports();

        /**
         * Returns true if {@link #getFileEvaluated()} satisfies all of the {@link FileChecks} specified in the {@link
         * InnerSourceReadinessSpecification} that was supplied to {@link InnerSourceReadinessReportCommand}.
         *
         * @return true if {@link #getFileChecksEvaluated()} are all satisfied for {@link #getFileEvaluated()}, false
         * otherwise.
         */
        @Derived
        public boolean isFileChecksSatisfied() {
            return getFileCheckReports()
                .stream()
                .allMatch(FileCheckReport::isFileCheckSatisfied);
        }

        /**
         * Returns true if {@code check} is a {@link FileCheck} in {@link #getFileChecksEvaluated()} AND was satisfied
         * by {@link #getFileEvaluated()} during execution of {@link InnerSourceReadinessReportCommand}, false
         * otherwise.
         *
         * @param check the {@code FileCheck} to check if satisfied for the evaluated file.
         * @return true if the {@code check} was satisfied for the evaluated file, false if the file check was not
         * evaluated against the evaluated file or if the file did not satisfy the check.
         */
        public boolean isFileCheckSatisfied(final FileCheck check) {
            return getFileCheckReports()
                .stream()
                .filter(
                    fileCheckReport ->
                        fileCheckReport.getFileCheckEvaluated().equals(check)
                )
                .anyMatch(FileCheckReport::isFileCheckSatisfied);
        }

        /**
         * Returns the {@link FileCheckReport} corresponding to the specified {@code check} if the {@code check} was
         * defined in the {@link InnerSourceReadinessSpecification} and evaluated as part of the {@link
         * #getFileChecksEvaluated()}, otherwise an empty {@link Optional} is returned.
         *
         * @param check the {@code FileCheck} to obtain a {@link FileCheckReport} for.
         * @return an {@link Optional} containing a {@link FileCheckReport} if {@code check} is a member of {@link
         * #getFileChecksEvaluated()} and was evaluated against {@link #getFileEvaluated()}, otherwise {@link
         * Optional#empty()}.
         */
        public Optional<FileCheckReport> getFileCheckReportFor(final FileCheck check) {
            return getFileCheckReports()
                .stream()
                .filter(
                    fileCheckReport ->
                        fileCheckReport.getFileCheckEvaluated().equals(check)
                )
                .findFirst();
        }
    }

    /**
     * An immutable report on a {@link FileRequirement} which indicates the {@link FileRequirementOption} evaluated and
     * which files in the scanned git repository were evaluated for the various {@link FileChecks} specified on the
     * {@link FileRequirement} in the {@link InnerSourceReadinessSpecification} supplied to the {@link
     * InnerSourceReadinessReportCommand}.
     *
     * @author Matt Madson
     * @since 1.0.0
     */
    @Immutable
    @Style(
        visibility = ImplementationVisibility.PACKAGE,
        builderVisibility = BuilderVisibility.PACKAGE
    )
    public abstract static class FileRequirementReport {

        FileRequirementReport() {}

        /**
         * Returns the {@link FileRequirement} as specified in the {@link InnerSourceReadinessSpecification} supplied to
         * the {@link InnerSourceReadinessReportCommand} which {@code this} report pertains to.
         *
         * @return the {@code FileRequirement} for this report.
         */
        public abstract FileRequirement getFileRequirementEvaluated();

        /**
         * When a FileRequirement can be satisfied in various ways. See: {@link FileRequirement#oneOf}.
         * This method returns the {@link FileRequirementOption} that pertains to this report.
         * Each option will have it's own report. In the case where a FileRequirement is
         * created with a single option. See: {@link FileRequirement#create}, this will be set
         * to the implicit singular option defined when the single FileRequirement was created.
         *
         * @return the option in {@link #getFileRequirementEvaluated()} that was evaluated and for which this report
         * pertains to.
         */
        public abstract FileRequirementOption getOptionEvaluated();

        /**
         * Returns the list of files or directories located in any of the {@link DirectoriesToSearch} whose base
         * filename matches the base filename of the {@link FileToFind} in the {@link
         * InnerSourceReadinessSpecification}. These files are the candidate files which are evaluated against the
         * specified {@link FileChecks}.
         *
         * @return the list of candidate files in any of the directories to search who are evaluated against the
         * specified FileChecks.
         */
        public abstract List<RepositoryFilePath> getFilesEvaluated();

        /**
         * Returns the list of repository files or directories that were found in any of the {@link DirectoriesToSearch}
         * which satisfy ALL of the {@link FileChecks} for the specified {@link #getFileRequirementEvaluated()}.
         *
         * @return a list of files or directories in the scanned repository who satisfy all the file checks for the file
         * requirement specified in the readiness specification.
         */
        public abstract List<RepositoryFilePath> getFilesSatisfyingFileChecks();

        /**
         * Returns a list of {@link FileChecksReport}, one for each {@link #getFilesEvaluated()}, which represents a
         * collection of {@link FileCheckReport}, one for each {@link FileCheck} in the specified {@link FileChecks} for
         * this {@link FileRequirement} / {@link FileRequirementOption}. Each report contains information on which file
         * checks were or were not satisfied for the evaluated (scanned) file.
         *
         * @return the list of reports for each of the evaluated files which contains information on what FileChecks
         * were or were not satisfied for the evaluated file.
         */
        public abstract List<FileChecksReport> getFileChecksReports();

        /**
         * Returns true if the {@link FileRequirement} evaluated by this report AND the {@link FileRequirementOption}
         * evaluated by this report was satisfied, meaning at least 1 file was found in one of the {@link
         * DirectoriesToSearch} that satisfied all of the {@link FileChecks} specified by this {@link
         * FileRequirementOption} in this {@link InnerSourceReadinessSpecification}. {@link FileChecks}
         *
         * @return true if the requirement and option evaluated for this report was satisfied during the scan of the git
         * repository by at least 1 file in one of the directories to search.
         */
        @Derived
        public boolean isFileRequirementSatisfied() {
            return !getFilesSatisfyingFileChecks().isEmpty();
        }

        /**
         * Returns the {@link FileChecksReport} for the specified {@code evaluatedFilePath} which should be one of the
         * {@link RepositoryFilePath} returned from {@link #getFilesEvaluated()}.
         *
         * @param evaluatedFilePath the path of the evaluated file to lookup the FileChecksReport for.
         * @return an {@link Optional} containing a {@link FileChecksReport} if one was generated for the file path
         * specified by {@code evaluatedFilePath}, {@link Optional#empty()} otherwise.
         */
        public Optional<FileChecksReport> getFileChecksReportFor(
            final RepositoryFilePath evaluatedFilePath
        ) {
            return getFileChecksReports()
                .stream()
                .filter(report -> report.getFileEvaluated().equals(evaluatedFilePath))
                .findFirst();
        }
    }

    InnerSourceReadinessReport() {}

    /**
     * Returns the {@link InnerSourceReadinessSpecification} that was evaluated by the {@link
     * InnerSourceReadinessReportCommand} in order to generate {@code this} report.
     *
     * @return the innersource readiness specification that was used when evaluating the git repository.
     */
    public abstract InnerSourceReadinessSpecification getSpecificationEvaluated();

    /**
     * Returns the list of {@link FileRequirementReport} for each of the required files specified in the {@link
     * #getSpecificationEvaluated()}.
     *
     * @return the list of file requirement reports
     */
    public abstract List<FileRequirementReport> getFileRequirementReports();

    /**
     * Returns true if the git repository scanned by executing the {@link InnerSourceReadinessReportCommand} contained
     * files which satisfied all the requirements and checks defined by the {@link #getSpecificationEvaluated()
     * InnerSourceReadinessSpecification}.
     *
     * @return true if the scanned git repository is InnerSource ready according to supplied specification, false
     * otherwise.
     */
    @Derived
    public boolean isRepositoryInnerSourceReady() {
        return getSpecificationEvaluated()
            .repositoryRequirements()
            .requiredFiles()
            .stream()
            .allMatch(this::isFileRequirementSatisfied);
    }

    /**
     * Returns true if {@code requirement} was defined in {@link #getSpecificationEvaluated()} and the requirement was
     * satisfied by the files in the target git repository during execution of the {@link
     * InnerSourceReadinessReportCommand}, false otherwise.
     * <br><br>
     * <p><strong>NOTE:</strong> If the file requirement contains multiple {@link FileRequirementOption}, this
     * will return true if ANY of the options were satisfied.
     *
     * @param requirement the requirement to check
     * @return true if the requirement was satisfied for the scanned git repository, false otherwise.
     */
    public boolean isFileRequirementSatisfied(final FileRequirement requirement) {
        return getFileRequirementReports()
            .stream()
            .filter(report -> report.getFileRequirementEvaluated().equals(requirement))
            .anyMatch(FileRequirementReport::isFileRequirementSatisfied);
    }

    /**
     * Returns true if {@code requirementOption} was defined in {@link #getSpecificationEvaluated()} and the requirement
     * was satisfied by the files in the target git repository during execution of the {@link
     * InnerSourceReadinessReportCommand}, false otherwise.
     * <br><br>
     * <p><strong>NOTE:</strong> This will only return true if the specific option defined by {@code requirementOption}
     * was satisfied by the files in the scanned git repository.
     *
     * @param requirementOption the requirement option to check
     * @return true if the requirement option was satisfied for the scanned git repository, false otherwise.
     */
    public boolean isFileRequirementSatisfied(
        final FileRequirementOption requirementOption
    ) {
        return getFileRequirementReports()
            .stream()
            .filter(report -> report.getOptionEvaluated().equals(requirementOption))
            .findFirst()
            .map(FileRequirementReport::isFileRequirementSatisfied)
            .orElse(false);
    }

    /**
     * Returns the {@link FileRequirementReport} for a {@link FileRequirement} which only has a single {@link
     * FileRequirementOption} typically created using the static factory method {@link
     * FileRequirement#create}. If the {@link FileRequirement} was not defined in the
     * specification evaluated during execution of the {@link InnerSourceReadinessReportCommand} which generated this
     * report, {@link Optional#empty()} will be returned.
     *
     * @param requirement - the FileRequirement to lookup the report for.
     * @return an {@link Optional} containing the {@link FileRequirementReport} corresponding to {@code requirement} if
     * requirement was defined on {@link #getSpecificationEvaluated()} and only permits a single option, {@link
     * Optional#empty()}, otherwise.
     * @throws IllegalArgumentException if {@link FileRequirement} contains multiple {@link FileRequirementOption}s and
     *                                  thus matches multiple {@link FileRequirementReport}s.
     */
    public Optional<FileRequirementReport> getOnlyFileRequirementReportFor(
        final FileRequirement requirement
    ) {
        final List<FileRequirementReport> reports = getFileRequirementReports()
            .stream()
            .filter(report -> report.getFileRequirementEvaluated().equals(requirement))
            .collect(Collectors.toList());
        return reports.isEmpty()
            ? Optional.empty()
            : Optional.of(Iterables.getOnlyElement(reports));
    }

    /**
     * Lookup the {@link FileRequirementReport}s for each of the {@link FileRequirementOption} permitted by the target
     * {@code requirement}.
     *
     * @param requirement the FileRequirement with multiple options defined on the InnerSourceReadinessSpecification.
     * @return the list of {@link FileRequirementReport}s for each of the options of the specified {@code requirement}.
     */
    public List<FileRequirementReport> getFileRequirementReportsFor(
        final FileRequirement requirement
    ) {
        return getFileRequirementReports()
            .stream()
            .filter(report -> report.getFileRequirementEvaluated().equals(requirement))
            .collect(Collectors.toList());
    }

    /**
     * Lookup the {@link FileRequirementReport} for the specific {@link FileRequirementOption} of some {@link
     * FileRequirement} as specified in the {@link #getSpecificationEvaluated()}. Returns an {@link Optional#empty()},
     * if the option was not specified in the {@link InnerSourceReadinessSpecification}.
     *
     * @param requirementOption the option to lookup the file requirement report for.
     * @return the FileRequirementReport for the specified {@code requirementOption}
     */
    public Optional<FileRequirementReport> getFileRequirementReportFor(
        final FileRequirementOption requirementOption
    ) {
        return getFileRequirementReports()
            .stream()
            .filter(report -> report.getOptionEvaluated().equals(requirementOption))
            .findFirst();
    }

    /**
     * Serializes {@code this} instance into its JSON representation and returns the result as a {@link String}.
     *
     * @return the json representation of this instance.
     */
    public String toJson() {
        return JsonService.getInstance().toJson(this);
    }
}
